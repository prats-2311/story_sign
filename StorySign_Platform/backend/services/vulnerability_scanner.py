"""
Vulnerability scanner service for security assessment
"""

import asyncio
import aiohttp
import ssl
import socket
import subprocess
import json
import re
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime, timedelta
from pathlib import Path
import logging

from core.base_service import BaseService


class VulnerabilityType:
    """Vulnerability types"""
    OUTDATED_DEPENDENCY = "outdated_dependency"
    INSECURE_CONFIG = "insecure_config"
    WEAK_CIPHER = "weak_cipher"
    MISSING_HEADER = "missing_security_header"
    EXPOSED_SERVICE = "exposed_service"
    WEAK_PASSWORD_POLICY = "weak_password_policy"
    INSECURE_PROTOCOL = "insecure_protocol"
    INFORMATION_DISCLOSURE = "information_disclosure"
    INJECTION_VULNERABILITY = "injection_vulnerability"
    AUTHENTICATION_BYPASS = "authentication_bypass"


class VulnerabilitySeverity:
    """Vulnerability severity levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnerabilityScanner(BaseService):
    """
    Service for scanning and detecting security vulnerabilities
    """
    
    def __init__(self, service_name: str = "VulnerabilityScanner", config: Optional[Dict[str, Any]] = None):
        super().__init__(service_name, config)
        
        # Configuration
        self.scan_interval = config.get("scan_interval", 86400) if config else 86400  # 24 hours
        self.enable_dependency_scan = config.get("enable_dependency_scan", True) if config else True
        self.enable_config_scan = config.get("enable_config_scan", True) if config else True
        self.enable_network_scan = config.get("enable_network_scan", True) if config else True
        self.enable_web_scan = config.get("enable_web_scan", True) if config else True
        
        # Scan results
        self.last_scan_time = None
        self.vulnerabilities = []
        self.scan_history = []
        
        # Known vulnerability patterns
        self.vulnerability_patterns = self._initialize_vulnerability_patterns()
        
    async def initialize(self) -> None:
        """Initialize vulnerability scanner"""
        self.logger.info("Vulnerability scanner initialized")
        
        # Start background scanning
        asyncio.create_task(self._periodic_scan())
    
    async def cleanup(self) -> None:
        """Clean up vulnerability scanner"""
        pass
    
    def _initialize_vulnerability_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize vulnerability detection patterns"""
        return {
            "insecure_headers": [
                {
                    "name": "Missing X-Frame-Options",
                    "check": "x-frame-options",
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "description": "Missing X-Frame-Options header allows clickjacking attacks"
                },
                {
                    "name": "Missing X-Content-Type-Options",
                    "check": "x-content-type-options",
                    "severity": VulnerabilitySeverity.LOW,
                    "description": "Missing X-Content-Type-Options header allows MIME sniffing"
                },
                {
                    "name": "Missing X-XSS-Protection",
                    "check": "x-xss-protection",
                    "severity": VulnerabilitySeverity.MEDIUM,
                    "description": "Missing X-XSS-Protection header"
                },
                {
                    "name": "Missing Strict-Transport-Security",
                    "check": "strict-transport-security",
                    "severity": VulnerabilitySeverity.HIGH,
                    "description": "Missing HSTS header allows protocol downgrade attacks"
                },
                {
                    "name": "Missing Content-Security-Policy",
                    "check": "content-security-policy",
                    "severity": VulnerabilitySeverity.HIGH,
                    "description": "Missing CSP header allows XSS attacks"
                }
            ],
            "insecure_configs": [
                {
                    "name": "Debug Mode Enabled",
                    "pattern": r"debug\s*=\s*true",
                    "severity": VulnerabilitySeverity.HIGH,
                    "description": "Debug mode enabled in production"
                },
                {
                    "name": "Default Credentials",
                    "pattern": r"(password|secret|key)\s*=\s*(admin|password|123456|default)",
                    "severity": VulnerabilitySeverity.CRITICAL,
                    "description": "Default or weak credentials detected"
                },
                {
                    "name": "Hardcoded Secrets",
                    "pattern": r"(api_key|secret_key|password)\s*=\s*['\"][^'\"]{8,}['\"]",
                    "severity": VulnerabilitySeverity.HIGH,
                    "description": "Hardcoded secrets in configuration"
                }
            ],
            "weak_ciphers": [
                "RC4", "DES", "3DES", "MD5", "SHA1"
            ],
            "dangerous_functions": [
                "eval", "exec", "system", "shell_exec", "passthru"
            ]
        }
    
    async def run_full_scan(self) -> Dict[str, Any]:
        """
        Run a comprehensive vulnerability scan
        
        Returns:
            Scan results with detected vulnerabilities
        """
        try:
            self.logger.info("Starting comprehensive vulnerability scan")
            scan_start = datetime.utcnow()
            
            vulnerabilities = []
            scan_results = {
                "scan_id": f"scan_{int(scan_start.timestamp())}",
                "start_time": scan_start.isoformat(),
                "scan_types": []
            }
            
            # 1. Dependency vulnerability scan
            if self.enable_dependency_scan:
                self.logger.info("Running dependency vulnerability scan")
                dep_vulns = await self._scan_dependencies()
                vulnerabilities.extend(dep_vulns)
                scan_results["scan_types"].append("dependencies")
            
            # 2. Configuration vulnerability scan
            if self.enable_config_scan:
                self.logger.info("Running configuration vulnerability scan")
                config_vulns = await self._scan_configurations()
                vulnerabilities.extend(config_vulns)
                scan_results["scan_types"].append("configurations")
            
            # 3. Network vulnerability scan
            if self.enable_network_scan:
                self.logger.info("Running network vulnerability scan")
                network_vulns = await self._scan_network()
                vulnerabilities.extend(network_vulns)
                scan_results["scan_types"].append("network")
            
            # 4. Web application vulnerability scan
            if self.enable_web_scan:
                self.logger.info("Running web application vulnerability scan")
                web_vulns = await self._scan_web_application()
                vulnerabilities.extend(web_vulns)
                scan_results["scan_types"].append("web_application")
            
            # Update scan results
            scan_end = datetime.utcnow()
            scan_results.update({
                "end_time": scan_end.isoformat(),
                "duration_seconds": (scan_end - scan_start).total_seconds(),
                "vulnerabilities_found": len(vulnerabilities),
                "vulnerabilities": vulnerabilities,
                "summary": self._generate_scan_summary(vulnerabilities)
            })
            
            # Store results
            self.vulnerabilities = vulnerabilities
            self.last_scan_time = scan_start
            self.scan_history.append(scan_results)
            
            # Keep only last 10 scans
            if len(self.scan_history) > 10:
                self.scan_history.pop(0)
            
            self.logger.info(f"Vulnerability scan completed: {len(vulnerabilities)} vulnerabilities found")
            return scan_results
            
        except Exception as e:
            self.logger.error(f"Vulnerability scan error: {e}")
            return {
                "error": str(e),
                "scan_id": f"scan_error_{int(datetime.utcnow().timestamp())}",
                "vulnerabilities": []
            }
    
    async def _scan_dependencies(self) -> List[Dict[str, Any]]:
        """Scan for vulnerable dependencies"""
        vulnerabilities = []
        
        try:
            # Check Python dependencies
            python_vulns = await self._scan_python_dependencies()
            vulnerabilities.extend(python_vulns)
            
            # Check Node.js dependencies
            nodejs_vulns = await self._scan_nodejs_dependencies()
            vulnerabilities.extend(nodejs_vulns)
            
        except Exception as e:
            self.logger.error(f"Dependency scan error: {e}")
        
        return vulnerabilities
    
    async def _scan_python_dependencies(self) -> List[Dict[str, Any]]:
        """Scan Python dependencies for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Use safety to check for known vulnerabilities
            result = subprocess.run(
                ["safety", "check", "--json"],
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                # No vulnerabilities found
                return vulnerabilities
            
            # Parse safety output
            try:
                safety_data = json.loads(result.stdout)
                for vuln in safety_data:
                    vulnerabilities.append({
                        "type": VulnerabilityType.OUTDATED_DEPENDENCY,
                        "severity": self._map_safety_severity(vuln.get("vulnerability_id")),
                        "title": f"Vulnerable Python package: {vuln.get('package_name')}",
                        "description": vuln.get("advisory"),
                        "affected_component": vuln.get("package_name"),
                        "installed_version": vuln.get("installed_version"),
                        "vulnerable_spec": vuln.get("vulnerable_spec"),
                        "cve_id": vuln.get("vulnerability_id"),
                        "remediation": f"Update {vuln.get('package_name')} to a safe version"
                    })
            except json.JSONDecodeError:
                pass
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Python dependency scan timed out")
        except FileNotFoundError:
            self.logger.warning("Safety tool not found - install with: pip install safety")
        except Exception as e:
            self.logger.error(f"Python dependency scan error: {e}")
        
        return vulnerabilities
    
    async def _scan_nodejs_dependencies(self) -> List[Dict[str, Any]]:
        """Scan Node.js dependencies for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check if package.json exists
            package_json_path = Path("StorySign_Platform/frontend/package.json")
            if not package_json_path.exists():
                return vulnerabilities
            
            # Use npm audit
            result = subprocess.run(
                ["npm", "audit", "--json"],
                cwd=package_json_path.parent,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            try:
                audit_data = json.loads(result.stdout)
                
                if "vulnerabilities" in audit_data:
                    for package, vuln_info in audit_data["vulnerabilities"].items():
                        severity = vuln_info.get("severity", "low")
                        
                        vulnerabilities.append({
                            "type": VulnerabilityType.OUTDATED_DEPENDENCY,
                            "severity": self._map_npm_severity(severity),
                            "title": f"Vulnerable Node.js package: {package}",
                            "description": vuln_info.get("title", "No description available"),
                            "affected_component": package,
                            "installed_version": vuln_info.get("version"),
                            "cve_id": vuln_info.get("cwe", [None])[0] if vuln_info.get("cwe") else None,
                            "remediation": f"Update {package} to fix vulnerability"
                        })
            except json.JSONDecodeError:
                pass
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Node.js dependency scan timed out")
        except FileNotFoundError:
            self.logger.warning("npm not found - Node.js dependencies not scanned")
        except Exception as e:
            self.logger.error(f"Node.js dependency scan error: {e}")
        
        return vulnerabilities
    
    async def _scan_configurations(self) -> List[Dict[str, Any]]:
        """Scan configuration files for security issues"""
        vulnerabilities = []
        
        try:
            # Scan common configuration files
            config_files = [
                "StorySign_Platform/backend/config.py",
                "StorySign_Platform/backend/config.yaml",
                "StorySign_Platform/backend/.env",
                "StorySign_Platform/frontend/.env",
                "StorySign_Platform/docker-compose.yml"
            ]
            
            for config_file in config_files:
                file_path = Path(config_file)
                if file_path.exists():
                    file_vulns = await self._scan_config_file(file_path)
                    vulnerabilities.extend(file_vulns)
            
        except Exception as e:
            self.logger.error(f"Configuration scan error: {e}")
        
        return vulnerabilities
    
    async def _scan_config_file(self, file_path: Path) -> List[Dict[str, Any]]:
        """Scan individual configuration file"""
        vulnerabilities = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check for insecure configuration patterns
            for config_check in self.vulnerability_patterns["insecure_configs"]:
                pattern = config_check["pattern"]
                matches = re.finditer(pattern, content, re.IGNORECASE)
                
                for match in matches:
                    line_num = content[:match.start()].count('\n') + 1
                    
                    vulnerabilities.append({
                        "type": VulnerabilityType.INSECURE_CONFIG,
                        "severity": config_check["severity"],
                        "title": config_check["name"],
                        "description": config_check["description"],
                        "affected_component": str(file_path),
                        "location": f"Line {line_num}",
                        "evidence": match.group(0),
                        "remediation": "Review and secure configuration"
                    })
            
        except Exception as e:
            self.logger.error(f"Config file scan error for {file_path}: {e}")
        
        return vulnerabilities
    
    async def _scan_network(self) -> List[Dict[str, Any]]:
        """Scan network configuration for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for open ports
            open_ports = await self._scan_open_ports()
            for port_info in open_ports:
                if port_info["risk_level"] in ["medium", "high"]:
                    vulnerabilities.append({
                        "type": VulnerabilityType.EXPOSED_SERVICE,
                        "severity": port_info["risk_level"],
                        "title": f"Exposed service on port {port_info['port']}",
                        "description": f"Service {port_info['service']} is exposed on port {port_info['port']}",
                        "affected_component": f"Port {port_info['port']}",
                        "remediation": "Review if this service needs to be publicly accessible"
                    })
            
            # Check SSL/TLS configuration
            ssl_vulns = await self._scan_ssl_configuration()
            vulnerabilities.extend(ssl_vulns)
            
        except Exception as e:
            self.logger.error(f"Network scan error: {e}")
        
        return vulnerabilities
    
    async def _scan_open_ports(self) -> List[Dict[str, Any]]:
        """Scan for open ports"""
        open_ports = []
        
        try:
            # Common ports to check
            ports_to_check = [
                (22, "SSH", "medium"),
                (23, "Telnet", "high"),
                (25, "SMTP", "low"),
                (53, "DNS", "low"),
                (80, "HTTP", "low"),
                (110, "POP3", "medium"),
                (143, "IMAP", "medium"),
                (443, "HTTPS", "low"),
                (993, "IMAPS", "low"),
                (995, "POP3S", "low"),
                (3306, "MySQL", "high"),
                (5432, "PostgreSQL", "high"),
                (6379, "Redis", "high"),
                (27017, "MongoDB", "high")
            ]
            
            for port, service, risk in ports_to_check:
                if await self._is_port_open("localhost", port):
                    open_ports.append({
                        "port": port,
                        "service": service,
                        "risk_level": risk
                    })
            
        except Exception as e:
            self.logger.error(f"Port scan error: {e}")
        
        return open_ports
    
    async def _is_port_open(self, host: str, port: int, timeout: float = 1.0) -> bool:
        """Check if a port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except Exception:
            return False
    
    async def _scan_ssl_configuration(self) -> List[Dict[str, Any]]:
        """Scan SSL/TLS configuration"""
        vulnerabilities = []
        
        try:
            # Check SSL configuration for HTTPS endpoints
            endpoints = ["localhost:443", "localhost:8443"]
            
            for endpoint in endpoints:
                host, port = endpoint.split(":")
                port = int(port)
                
                if await self._is_port_open(host, port):
                    ssl_vulns = await self._check_ssl_endpoint(host, port)
                    vulnerabilities.extend(ssl_vulns)
            
        except Exception as e:
            self.logger.error(f"SSL scan error: {e}")
        
        return vulnerabilities
    
    async def _check_ssl_endpoint(self, host: str, port: int) -> List[Dict[str, Any]]:
        """Check SSL configuration for specific endpoint"""
        vulnerabilities = []
        
        try:
            # Create SSL context
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Connect and get certificate info
            with socket.create_connection((host, port), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    
                    # Check for weak ciphers
                    if cipher and cipher[0] in self.vulnerability_patterns["weak_ciphers"]:
                        vulnerabilities.append({
                            "type": VulnerabilityType.WEAK_CIPHER,
                            "severity": VulnerabilitySeverity.MEDIUM,
                            "title": f"Weak cipher suite: {cipher[0]}",
                            "description": f"Endpoint {host}:{port} uses weak cipher {cipher[0]}",
                            "affected_component": f"{host}:{port}",
                            "remediation": "Configure stronger cipher suites"
                        })
                    
                    # Check certificate expiration
                    if cert:
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.utcnow()).days
                        
                        if days_until_expiry < 30:
                            severity = VulnerabilitySeverity.HIGH if days_until_expiry < 7 else VulnerabilitySeverity.MEDIUM
                            vulnerabilities.append({
                                "type": VulnerabilityType.INSECURE_CONFIG,
                                "severity": severity,
                                "title": "SSL certificate expiring soon",
                                "description": f"Certificate for {host}:{port} expires in {days_until_expiry} days",
                                "affected_component": f"{host}:{port}",
                                "remediation": "Renew SSL certificate"
                            })
            
        except Exception as e:
            self.logger.debug(f"SSL check error for {host}:{port}: {e}")
        
        return vulnerabilities
    
    async def _scan_web_application(self) -> List[Dict[str, Any]]:
        """Scan web application for vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check security headers
            header_vulns = await self._check_security_headers()
            vulnerabilities.extend(header_vulns)
            
            # Check for information disclosure
            info_vulns = await self._check_information_disclosure()
            vulnerabilities.extend(info_vulns)
            
        except Exception as e:
            self.logger.error(f"Web application scan error: {e}")
        
        return vulnerabilities
    
    async def _check_security_headers(self) -> List[Dict[str, Any]]:
        """Check for missing security headers"""
        vulnerabilities = []
        
        try:
            # Test endpoints
            endpoints = ["http://localhost:8000", "https://localhost:8443"]
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                for endpoint in endpoints:
                    try:
                        async with session.get(endpoint) as response:
                            headers = response.headers
                            
                            # Check for missing security headers
                            for header_check in self.vulnerability_patterns["insecure_headers"]:
                                header_name = header_check["check"]
                                
                                if header_name not in headers:
                                    vulnerabilities.append({
                                        "type": VulnerabilityType.MISSING_HEADER,
                                        "severity": header_check["severity"],
                                        "title": header_check["name"],
                                        "description": header_check["description"],
                                        "affected_component": endpoint,
                                        "remediation": f"Add {header_name} header to HTTP responses"
                                    })
                    
                    except Exception as e:
                        self.logger.debug(f"Header check error for {endpoint}: {e}")
        
        except Exception as e:
            self.logger.error(f"Security headers check error: {e}")
        
        return vulnerabilities
    
    async def _check_information_disclosure(self) -> List[Dict[str, Any]]:
        """Check for information disclosure vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Check for exposed debug endpoints
            debug_endpoints = [
                "/debug",
                "/admin",
                "/.env",
                "/config",
                "/status",
                "/health"
            ]
            
            base_url = "http://localhost:8000"
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:
                for endpoint in debug_endpoints:
                    try:
                        async with session.get(f"{base_url}{endpoint}") as response:
                            if response.status == 200:
                                content = await response.text()
                                
                                # Check if response contains sensitive information
                                if any(keyword in content.lower() for keyword in 
                                      ["password", "secret", "key", "token", "debug", "error"]):
                                    vulnerabilities.append({
                                        "type": VulnerabilityType.INFORMATION_DISCLOSURE,
                                        "severity": VulnerabilitySeverity.MEDIUM,
                                        "title": f"Information disclosure at {endpoint}",
                                        "description": f"Endpoint {endpoint} may expose sensitive information",
                                        "affected_component": f"{base_url}{endpoint}",
                                        "remediation": "Restrict access to debug endpoints or remove sensitive information"
                                    })
                    
                    except Exception as e:
                        self.logger.debug(f"Info disclosure check error for {endpoint}: {e}")
        
        except Exception as e:
            self.logger.error(f"Information disclosure check error: {e}")
        
        return vulnerabilities
    
    def _map_safety_severity(self, vuln_id: str) -> str:
        """Map safety vulnerability ID to severity"""
        # This is a simplified mapping
        # In production, you would have a more comprehensive mapping
        if not vuln_id:
            return VulnerabilitySeverity.MEDIUM
        
        vuln_id_lower = vuln_id.lower()
        if "critical" in vuln_id_lower or "rce" in vuln_id_lower:
            return VulnerabilitySeverity.CRITICAL
        elif "high" in vuln_id_lower:
            return VulnerabilitySeverity.HIGH
        elif "medium" in vuln_id_lower:
            return VulnerabilitySeverity.MEDIUM
        else:
            return VulnerabilitySeverity.LOW
    
    def _map_npm_severity(self, severity: str) -> str:
        """Map npm audit severity to internal severity"""
        severity_mapping = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "moderate": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "info": VulnerabilitySeverity.LOW
        }
        return severity_mapping.get(severity.lower(), VulnerabilitySeverity.MEDIUM)
    
    def _generate_scan_summary(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate scan summary statistics"""
        summary = {
            "total": len(vulnerabilities),
            "by_severity": {
                VulnerabilitySeverity.CRITICAL: 0,
                VulnerabilitySeverity.HIGH: 0,
                VulnerabilitySeverity.MEDIUM: 0,
                VulnerabilitySeverity.LOW: 0
            },
            "by_type": {}
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get("severity", VulnerabilitySeverity.LOW)
            vuln_type = vuln.get("type", "unknown")
            
            summary["by_severity"][severity] += 1
            summary["by_type"][vuln_type] = summary["by_type"].get(vuln_type, 0) + 1
        
        return summary
    
    async def _periodic_scan(self) -> None:
        """Run periodic vulnerability scans"""
        while True:
            try:
                await asyncio.sleep(self.scan_interval)
                
                self.logger.info("Starting scheduled vulnerability scan")
                await self.run_full_scan()
                
            except Exception as e:
                self.logger.error(f"Periodic scan error: {e}")
    
    async def get_vulnerability_report(self) -> Dict[str, Any]:
        """Get current vulnerability report"""
        return {
            "last_scan": self.last_scan_time.isoformat() if self.last_scan_time else None,
            "total_vulnerabilities": len(self.vulnerabilities),
            "vulnerabilities": self.vulnerabilities,
            "summary": self._generate_scan_summary(self.vulnerabilities),
            "scan_history": self.scan_history[-5:]  # Last 5 scans
        }